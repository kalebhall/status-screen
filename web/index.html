<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0" />
  <title>Status Display</title>
  <style>
    :root {
      color-scheme: only dark;
    }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: black;
      color: white;
      overflow: hidden;
    }
    .screen {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: stretch;
    }
    .row {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: calc(10px * var(--font-scale, 1));
      text-align: center;
      padding: calc(16px * var(--font-scale, 1));
      box-sizing: border-box;
    }
    .row + .row {
      border-top: 4px solid rgba(255, 255, 255, 0.2);
    }
    .label-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: calc(24px * var(--font-scale, 1));
    }
    .name {
      font-size: calc(64px * var(--font-scale, 1));
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    .label {
      font-size: calc(140px * var(--font-scale, 1));
      line-height: 1.0;
      font-weight: 700;
      text-transform: uppercase;
    }
    .status-icon {
      font-size: calc(120px * var(--font-scale, 1));
      line-height: 1.0;
      filter: drop-shadow(0 4px 4px rgba(0,0,0,0.35));
    }
    .detail {
      font-size: calc(64px * var(--font-scale, 1));
      opacity: 0.9;
      text-transform: none;
    }
    .next-event,
    .countdown {
      font-size: calc(52px * var(--font-scale, 1));
      opacity: 0.85;
      text-transform: none;
    }
    .available { background: #00a651; }
    .busy { background: #c0392b; }
    .meeting { background: #2980b9; }
    .ooo { background: #8e44ad; }
    .error { background: #7f8c8d; }
    .footer {
      position: absolute;
      bottom: 20px;
      right: 40px;
      font-size: calc(42px * var(--font-scale, 1));
      opacity: 0.85;
    }
  </style>
</head>
<body>
  <div id="screen" class="screen"></div>
  <div id="footer" class="footer"></div>

  <script>
    const footer = document.getElementById("footer");
    const screen = document.getElementById("screen");
    let rows = [];
    let rowState = [];

    const iconByState = {
      available: "‚úÖ",
      busy: "‚õî",
      meeting: "üìÖ",
      ooo: "‚úàÔ∏è",
      error: "‚ö†Ô∏è",
    };

    function fontScaleFor(count) {
      if (count <= 1) {
        return 1;
      }
      if (count === 2) {
        return 0.75;
      }
      if (count === 3) {
        return 0.6;
      }
      if (count === 4) {
        return 0.5;
      }
      return 0.4;
    }

    function createRow() {
      const row = document.createElement("div");
      row.className = "row available";

      const name = document.createElement("div");
      name.className = "name";

      const labelRow = document.createElement("div");
      labelRow.className = "label-row";

      const icon = document.createElement("span");
      icon.className = "status-icon";
      icon.textContent = "‚óè";

      const label = document.createElement("span");
      label.className = "label";
      label.textContent = "AVAILABLE";

      labelRow.appendChild(icon);
      labelRow.appendChild(label);

      const detail = document.createElement("div");
      detail.className = "detail";

      const nextEvent = document.createElement("div");
      nextEvent.className = "next-event";

      const countdown = document.createElement("div");
      countdown.className = "countdown";

      row.appendChild(name);
      row.appendChild(labelRow);
      row.appendChild(detail);
      row.appendChild(nextEvent);
      row.appendChild(countdown);

      return { row, name, icon, label, detail, nextEvent, countdown };
    }

    function setRowCount(count) {
      const targetCount = Math.max(1, count);
      if (rows.length === targetCount) {
        return;
      }
      screen.innerHTML = "";
      rows = [];
      rowState = [];
      for (let i = 0; i < targetCount; i += 1) {
        const row = createRow();
        rows.push(row);
        rowState.push({ until: null, state: "available", nextEventAt: null, timeZone: null });
        screen.appendChild(row.row);
      }
      screen.style.setProperty("--font-scale", fontScaleFor(targetCount));
    }

    function formatCountdown(msRemaining) {
      const totalSeconds = Math.max(0, Math.floor(msRemaining / 1000));
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      if (minutes > 0) {
        return `${minutes}m ${seconds}s`;
      }
      return `${seconds}s`;
    }

    function updateCountdown(index) {
      const state = rowState[index];
      const row = rows[index];
      if (!row || !state || !state.until || ["available", "ooo"].includes(state.state)) {
        if (row) {
          row.countdown.textContent = "";
        }
        return;
      }
      const endTime = new Date(state.until);
      if (Number.isNaN(endTime.getTime())) {
        row.countdown.textContent = "";
        return;
      }
      const remaining = endTime.getTime() - Date.now();
      if (remaining <= 0) {
        row.countdown.textContent = "Ending now";
        return;
      }
      row.countdown.textContent = `Ends in ${formatCountdown(remaining)}`;
    }

    function parseTimeZoneOffset(timeZone) {
      if (!timeZone) {
        return null;
      }
      const match = timeZone.match(/^(?:UTC|GMT)\s*([+-])\s*(\d{1,2})(?::?(\d{2}))?$/i);
      if (!match) {
        return null;
      }
      const sign = match[1] === "-" ? -1 : 1;
      const hours = Number.parseInt(match[2], 10);
      const minutes = match[3] ? Number.parseInt(match[3], 10) : 0;
      if (Number.isNaN(hours) || Number.isNaN(minutes) || hours > 14 || minutes > 59) {
        return null;
      }
      return sign * (hours * 60 + minutes);
    }

    function formatTimeWithOffset(date, offsetMinutes, options) {
      const adjusted = new Date(date.getTime() + offsetMinutes * 60 * 1000);
      return adjusted.toLocaleTimeString("en-US", {
        ...options,
        timeZone: "UTC",
      });
    }

    function formatDateWithOffset(date, offsetMinutes, options) {
      const adjusted = new Date(date.getTime() + offsetMinutes * 60 * 1000);
      return adjusted.toLocaleDateString("en-US", {
        ...options,
        timeZone: "UTC",
      });
    }

    function getZonedParts(date, timeZone) {
      if (timeZone) {
        const offsetMinutes = parseTimeZoneOffset(timeZone);
        if (offsetMinutes !== null) {
          const adjusted = new Date(date.getTime() + offsetMinutes * 60 * 1000);
          return {
            year: adjusted.getUTCFullYear(),
            month: adjusted.getUTCMonth(),
            day: adjusted.getUTCDate(),
            hour: adjusted.getUTCHours(),
            minute: adjusted.getUTCMinutes(),
          };
        }
        try {
          const parts = new Intl.DateTimeFormat("en-US", {
            timeZone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          }).formatToParts(date);
          const lookup = Object.fromEntries(parts.map((part) => [part.type, part.value]));
          return {
            year: Number.parseInt(lookup.year, 10),
            month: Number.parseInt(lookup.month, 10) - 1,
            day: Number.parseInt(lookup.day, 10),
            hour: Number.parseInt(lookup.hour, 10),
            minute: Number.parseInt(lookup.minute, 10),
          };
        } catch (error) {
          // Fall through to local time
        }
      }
      return {
        year: date.getFullYear(),
        month: date.getMonth(),
        day: date.getDate(),
        hour: date.getHours(),
        minute: date.getMinutes(),
      };
    }

    function isSameDay(first, second, timeZone) {
      const firstParts = getZonedParts(first, timeZone);
      const secondParts = getZonedParts(second, timeZone);
      return (
        firstParts.year === secondParts.year &&
        firstParts.month === secondParts.month &&
        firstParts.day === secondParts.day
      );
    }

    function isWithinWorkHours(date, timeZone) {
      const WORKDAY_START = 9;
      const WORKDAY_END = 17;
      const parts = getZonedParts(date, timeZone);
      return parts.hour >= WORKDAY_START && parts.hour < WORKDAY_END;
    }

    function formatTime(date, timeZone) {
      const baseOptions = {
        hour: "numeric",
        minute: "2-digit",
        hour12: true,
      };
      if (timeZone) {
        const offsetMinutes = parseTimeZoneOffset(timeZone);
        if (offsetMinutes !== null) {
          return formatTimeWithOffset(date, offsetMinutes, baseOptions);
        }
        try {
          return date.toLocaleTimeString("en-US", {
            ...baseOptions,
            timeZone,
          });
        } catch (error) {
          return date.toLocaleTimeString("en-US", baseOptions);
        }
      }
      return date.toLocaleTimeString("en-US", baseOptions);
    }

    function formatDate(date, timeZone) {
      const baseOptions = {
        month: "2-digit",
        day: "2-digit",
        year: "numeric",
      };
      if (timeZone) {
        const offsetMinutes = parseTimeZoneOffset(timeZone);
        if (offsetMinutes !== null) {
          return formatDateWithOffset(date, offsetMinutes, baseOptions);
        }
        try {
          return date.toLocaleDateString("en-US", {
            ...baseOptions,
            timeZone,
          });
        } catch (error) {
          return date.toLocaleDateString("en-US", baseOptions);
        }
      }
      return date.toLocaleDateString("en-US", baseOptions);
    }

    function updateNextEvent(index) {
      const state = rowState[index];
      const row = rows[index];
      if (!row || !state || !state.nextEventAt || state.state === "ooo") {
        if (row) {
          row.nextEvent.textContent = "";
        }
        return;
      }
      const nextTime = new Date(state.nextEventAt);
      if (Number.isNaN(nextTime.getTime())) {
        row.nextEvent.textContent = "";
        return;
      }
      const now = new Date();
      if (nextTime <= now) {
        row.nextEvent.textContent = "";
        return;
      }
      if (!isSameDay(nextTime, now, state.timeZone)) {
        row.nextEvent.textContent = "";
        return;
      }
      if (!isWithinWorkHours(nextTime, state.timeZone)) {
        row.nextEvent.textContent = "";
        return;
      }
      const formattedTime = formatTime(nextTime, state.timeZone);
      row.nextEvent.textContent = `Next event at ${formattedTime}`;
    }

    function updateClock() {
      const now = new Date();
      const zone = rowState[0] ? rowState[0].timeZone : null;
      footer.textContent = `${formatDate(now, zone)} ${formatTime(now, zone)}`;
    }

    function updateRow(index, person) {
      const row = rows[index];
      if (!row) {
        return;
      }
      const state = person.state || "error";
      row.row.className = `row ${state}`;
      row.icon.textContent = iconByState[state] || "‚óè";
      row.label.textContent = person.label || "UNKNOWN";
      row.detail.textContent = person.detail || "";
      row.name.textContent = person.name || `Group ${index + 1}`;
      rowState[index] = {
        until: person.until || null,
        state,
        nextEventAt: person.next_event_at || null,
        timeZone: person.time_zone || null,
      };
      updateCountdown(index);
      updateNextEvent(index);
    }

    async function fetchStatusPayload() {
      try {
        const r = await fetch("/status-multi.json?cache=" + Date.now());
        if (!r.ok) {
          throw new Error(`status-multi.json ${r.status}`);
        }
        return await r.json();
      } catch (error) {
        try {
          const r = await fetch("/status.json?cache=" + Date.now());
          if (!r.ok) {
            throw new Error(`status.json ${r.status}`);
          }
          return await r.json();
        } catch (fallbackError) {
          return null;
        }
      }
    }

    async function loadStatus() {
      const data = await fetchStatusPayload();
      if (!data) {
        setRowCount(1);
        updateRow(0, { state: "error", label: "STATUS ERROR", detail: "" });
        return;
      }
      const people = Array.isArray(data.people) ? data.people : [data];
      setRowCount(people.length);
      people.forEach((person, index) => updateRow(index, person));
    }

    setInterval(updateClock, 1000);
    setInterval(loadStatus, 2000);
    setInterval(() => rows.forEach((_, index) => updateCountdown(index)), 1000);
    setInterval(() => rows.forEach((_, index) => updateNextEvent(index)), 1000);
    updateClock();
    loadStatus();
  </script>
</body>
</html>
