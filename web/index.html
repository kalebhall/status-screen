<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0" />
  <title>Status Display</title>
  <style>
    :root {
      color-scheme: only dark;
      --screen-bg: #000000;
      --text-color: #ffffff;
      --divider-color: rgba(255, 255, 255, 0.2);
      --available-bg: #00a651;
      --busy-bg: #c0392b;
      --meeting-bg: #2980b9;
      --ooo-bg: #8e44ad;
      --error-bg: #7f8c8d;
      --icon-shadow: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.35));
    }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: var(--screen-bg);
      color: var(--text-color);
      overflow: hidden;
      cursor: none;
    }
    body.display-grayscale {
      color-scheme: only light;
      --screen-bg: #f7f7f7;
      --text-color: #111111;
      --divider-color: rgba(0, 0, 0, 0.2);
      --available-bg: #f7f7f7;
      --busy-bg: #d0d0d0;
      --meeting-bg: #b8b8b8;
      --ooo-bg: #c8c8c8;
      --error-bg: #a0a0a0;
      --icon-shadow: none;
    }
    body.display-tricolor {
      color-scheme: only light;
      --screen-bg: #ffffff;
      --text-color: #111111;
      --divider-color: rgba(0, 0, 0, 0.3);
      --available-bg: #ffffff;
      --busy-bg: #d32f2f;
      --meeting-bg: #e0e0e0;
      --ooo-bg: #b71c1c;
      --error-bg: #555555;
      --icon-shadow: none;
    }
    .screen {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: row;
      align-items: stretch;
      justify-content: stretch;
    }
    .column {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: stretch;
    }
    .column + .column {
      border-left: 4px solid var(--divider-color);
    }
    .row {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: calc(10px * var(--font-scale, 1));
      text-align: center;
      padding: calc(16px * var(--font-scale, 1));
      box-sizing: border-box;
    }
    .row + .row {
      border-top: 4px solid var(--divider-color);
    }
    .label-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: calc(24px * var(--font-scale, 1));
    }
    .name {
      font-size: calc(64px * var(--font-scale, 1));
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    .label {
      font-size: calc(140px * var(--font-scale, 1));
      line-height: 1.0;
      font-weight: 700;
      text-transform: uppercase;
    }
    .status-icon {
      font-size: calc(120px * var(--font-scale, 1));
      line-height: 1.0;
      filter: var(--icon-shadow);
    }
    .detail {
      font-size: calc(64px * var(--font-scale, 1));
      opacity: 0.9;
      text-transform: none;
    }
    .next-event,
    .countdown {
      font-size: calc(52px * var(--font-scale, 1));
      opacity: 0.85;
      text-transform: none;
    }
    .available { background: var(--available-bg); }
    .busy { background: var(--busy-bg); }
    .meeting { background: var(--meeting-bg); }
    .ooo { background: var(--ooo-bg); }
    .error { background: var(--error-bg); }
    .footer {
      position: absolute;
      bottom: 20px;
      right: 40px;
      font-size: calc(42px * var(--font-scale, 1));
      opacity: 0.85;
    }
  </style>
</head>
<body>
  <div id="screen" class="screen"></div>
  <div id="footer" class="footer"></div>

  <script>
    const footer = document.getElementById("footer");
    const screen = document.getElementById("screen");
    let rows = [];
    let rowState = [];
    let columnCount = 0;
    let rowsPerColumn = 0;

    const iconByState = {
      available: "‚úÖ",
      busy: "‚õî",
      meeting: "üìÖ",
      ooo: "‚úàÔ∏è",
      error: "‚ö†Ô∏è",
    };

    function fontScaleFor(count) {
      if (count <= 1) {
        return 1;
      }
      if (count === 2) {
        return 0.75;
      }
      if (count === 3) {
        return 0.6;
      }
      if (count === 4) {
        return 0.5;
      }
      return 0.4;
    }

    function createRow() {
      const row = document.createElement("div");
      row.className = "row available";

      const name = document.createElement("div");
      name.className = "name";

      const labelRow = document.createElement("div");
      labelRow.className = "label-row";

      const icon = document.createElement("span");
      icon.className = "status-icon";
      icon.textContent = "‚óè";

      const label = document.createElement("span");
      label.className = "label";
      label.textContent = "AVAILABLE";

      labelRow.appendChild(icon);
      labelRow.appendChild(label);

      const detail = document.createElement("div");
      detail.className = "detail";

      const nextEvent = document.createElement("div");
      nextEvent.className = "next-event";

      const countdown = document.createElement("div");
      countdown.className = "countdown";

      row.appendChild(name);
      row.appendChild(labelRow);
      row.appendChild(detail);
      row.appendChild(nextEvent);
      row.appendChild(countdown);

      return { row, name, icon, label, detail, nextEvent, countdown };
    }

    function createColumn() {
      const column = document.createElement("div");
      column.className = "column";
      return column;
    }

    function resolveRowsPerColumn(data, people) {
      const parsed = Number.parseInt(data && data.rows_per_column, 10);
      if (Number.isFinite(parsed) && parsed > 0) {
        return parsed;
      }
      return people.length || 1;
    }

    function resolveSelectedPerson() {
      const params = new URLSearchParams(window.location.search);
      const name = params.get("person");
      if (!name) {
        return null;
      }
      return name.trim().toLowerCase() || null;
    }

    function setRowCount(count, maxPerColumn) {
      const targetCount = Math.max(1, count);
      const targetPerColumn = Math.max(1, maxPerColumn || targetCount);
      const targetColumns = Math.max(1, Math.ceil(targetCount / targetPerColumn));
      if (
        rows.length === targetCount &&
        columnCount === targetColumns &&
        rowsPerColumn === targetPerColumn
      ) {
        return;
      }
      screen.innerHTML = "";
      rows = [];
      rowState = [];
      columnCount = targetColumns;
      rowsPerColumn = targetPerColumn;
      let column = null;
      for (let i = 0; i < targetCount; i += 1) {
        if (i % targetPerColumn === 0) {
          column = createColumn();
          screen.appendChild(column);
        }
        const row = createRow();
        rows.push(row);
        rowState.push({
          until: null,
          state: "available",
          nextEventAt: null,
          detail: "",
          source: "",
          timeZone: null,
        });
        column.appendChild(row.row);
      }
      screen.style.setProperty("--font-scale", fontScaleFor(targetPerColumn));
    }

    function formatCountdown(msRemaining) {
      const totalSeconds = Math.max(0, Math.floor(msRemaining / 1000));
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      if (minutes > 0) {
        return `${minutes}m ${seconds}s`;
      }
      return `${seconds}s`;
    }

    function isMicActive(detail) {
      return (detail || "").toLowerCase().includes("mic active");
    }

    function updateCountdown(index) {
      const state = rowState[index];
      const row = rows[index];
      if (
        !row ||
        !state ||
        !state.until ||
        ["available", "ooo"].includes(state.state) ||
        isMicActive(state.detail)
      ) {
        if (row) {
          row.countdown.textContent = "";
        }
        return;
      }
      const endTime = new Date(state.until);
      if (Number.isNaN(endTime.getTime())) {
        row.countdown.textContent = "";
        return;
      }
      const remaining = endTime.getTime() - Date.now();
      if (remaining <= 0) {
        row.countdown.textContent = "Ending now";
        return;
      }
      row.countdown.textContent = `Ends in ${formatCountdown(remaining)}`;
    }

    function formatTime(date) {
      const baseOptions = {
        hour: "numeric",
        minute: "2-digit",
        hour12: true,
      };
      return date.toLocaleTimeString("en-US", baseOptions);
    }

    function formatDate(date) {
      const baseOptions = {
        month: "2-digit",
        day: "2-digit",
        year: "numeric",
      };
      return date.toLocaleDateString("en-US", baseOptions);
    }

    function updateNextEvent(index) {
      const state = rowState[index];
      const row = rows[index];
      if (!row || !state || !state.nextEventAt || state.state === "ooo") {
        if (row) {
          row.nextEvent.textContent = "";
        }
        return;
      }
      const nextTime = new Date(state.nextEventAt);
      if (Number.isNaN(nextTime.getTime())) {
        row.nextEvent.textContent = "";
        return;
      }
      const now = new Date();
      if (nextTime <= now) {
        row.nextEvent.textContent = "";
        return;
      }
      const formattedTime = formatTime(nextTime);
      row.nextEvent.textContent = `Next event at ${formattedTime}`;
    }

    function updateClock() {
      const now = new Date();
      footer.textContent = `${formatDate(now)} ${formatTime(now)}`;
    }

    function updateRow(index, person) {
      const row = rows[index];
      if (!row) {
        return;
      }
      const state = person.state || "error";
      row.row.className = `row ${state}`;
      row.icon.textContent = iconByState[state] || "‚óè";
      row.label.textContent = person.label || "UNKNOWN";
      row.detail.textContent = person.detail || "";
      row.name.textContent = person.name || `Group ${index + 1}`;
      rowState[index] = {
        until: person.until || null,
        state,
        nextEventAt: person.next_event_at || null,
        detail: person.detail || "",
        source: person.source || "",
      };
      updateCountdown(index);
      updateNextEvent(index);
    }

    async function fetchStatusPath(path) {
      const response = await fetch(`${path}?cache=${Date.now()}`);
      if (!response.ok) {
        return null;
      }
      return await response.json();
    }

    async function fetchStatusPayload() {
      try {
        return await fetchStatusPath("/status.json");
      } catch (error) {
        return null;
      }
    }

    async function loadStatus() {
      const data = await fetchStatusPayload();
      if (!data) {
        setRowCount(1, 1);
        updateRow(0, { state: "error", label: "STATUS ERROR", detail: "" });
        return;
      }
      const people = Array.isArray(data.people) ? data.people : [data];
      const selectedPerson = resolveSelectedPerson();
      const filteredPeople = selectedPerson
        ? people.filter((person) => (person.name || "").toLowerCase() === selectedPerson)
        : people;
      applyDisplayMode(resolveDisplayMode(data, filteredPeople));
      if (selectedPerson && filteredPeople.length === 0) {
        setRowCount(1, 1);
        updateRow(0, {
          state: "error",
          label: "NOT FOUND",
          detail: `No match for "${selectedPerson}".`,
          name: "Unavailable",
        });
        return;
      }
      const targetRowsPerColumn = resolveRowsPerColumn(data, filteredPeople);
      setRowCount(filteredPeople.length, targetRowsPerColumn);
      filteredPeople.forEach((person, index) => updateRow(index, person));
    }

    function resolveDisplayMode(data, people) {
      if (data && data.display_mode) {
        return data.display_mode;
      }
      if (people && people.length > 0 && people[0].display_mode) {
        return people[0].display_mode;
      }
      return "color";
    }

    function applyDisplayMode(mode) {
      const normalized = (mode || "color").toLowerCase();
      document.body.classList.remove("display-grayscale", "display-tricolor");
      if (normalized === "grayscale") {
        document.body.classList.add("display-grayscale");
      } else if (normalized === "tricolor") {
        document.body.classList.add("display-tricolor");
      }
    }

    setInterval(updateClock, 1000);
    setInterval(loadStatus, 2000);
    setInterval(() => rows.forEach((_, index) => updateCountdown(index)), 1000);
    setInterval(() => rows.forEach((_, index) => updateNextEvent(index)), 1000);
    updateClock();
    loadStatus();
  </script>
</body>
</html>
