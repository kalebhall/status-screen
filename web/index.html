<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=1920, height=480, initial-scale=1.0" />
  <title>Status Display</title>
  <style>
    body { margin:0; font-family: Arial, sans-serif; background:black; color:white; overflow:hidden; }
    .bar { width: 1920px; height: 480px; display:flex; flex-direction:column; align-items:center; justify-content:center; font-weight:bold; text-transform:uppercase; }
    .label { font-size: 140px; line-height: 1.0; }
    .label-row { display:flex; align-items:center; gap: 30px; }
    .status-icon { font-size: 120px; line-height: 1.0; filter: drop-shadow(0 4px 4px rgba(0,0,0,0.35)); }
    .detail { font-size: 64px; opacity: 0.9; margin-top: 10px; text-transform:none; }
    .next-event { font-size: 52px; opacity: 0.85; margin-top: 12px; text-transform:none; }
    .countdown { font-size: 52px; opacity: 0.85; margin-top: 12px; text-transform:none; }
    .available { background:#00a651; }
    .busy { background:#c0392b; }
    .meeting { background:#2980b9; }
    .ooo { background:#8e44ad; }
    .error { background:#7f8c8d; }
    .footer { position:absolute; bottom:20px; right:40px; font-size:42px; opacity:0.85; }
  </style>
</head>
<body>
  <div id="bar" class="bar available">
    <div class="label label-row">
      <span id="icon" class="status-icon">‚óè</span>
      <span id="label">AVAILABLE</span>
    </div>
    <div id="detail" class="detail"></div>
    <div id="next-event" class="next-event"></div>
    <div id="countdown" class="countdown"></div>
  </div>
  <div id="footer" class="footer"></div>

  <script>
    const footer = document.getElementById("footer");
    const bar = document.getElementById("bar");
    const icon = document.getElementById("icon");
    const label = document.getElementById("label");
    const detail = document.getElementById("detail");
    const nextEvent = document.getElementById("next-event");
    const countdown = document.getElementById("countdown");
    let currentUntil = null;
    let currentState = "available";
    let currentNextEventAt = null;
    let currentTimeZone = null;

    const iconByState = {
      available: "‚úÖ",
      busy: "‚õî",
      meeting: "üìÖ",
      ooo: "‚úàÔ∏è",
      error: "‚ö†Ô∏è",
    };

    function formatCountdown(msRemaining) {
      const totalSeconds = Math.max(0, Math.floor(msRemaining / 1000));
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      if (minutes > 0) {
        return `${minutes}m ${seconds}s`;
      }
      return `${seconds}s`;
    }

    function updateCountdown(untilIso, state) {
      if (!untilIso || ["available", "ooo"].includes(state)) {
        countdown.textContent = "";
        return;
      }
      const endTime = new Date(untilIso);
      if (Number.isNaN(endTime.getTime())) {
        countdown.textContent = "";
        return;
      }
      const remaining = endTime.getTime() - Date.now();
      if (remaining <= 0) {
        countdown.textContent = "Ending now";
        return;
      }
      countdown.textContent = `Ends in ${formatCountdown(remaining)}`;
    }

    function parseTimeZoneOffset(timeZone) {
      if (!timeZone) {
        return null;
      }
      const match = timeZone.match(/^(?:UTC|GMT)\s*([+-])\s*(\d{1,2})(?::?(\d{2}))?$/i);
      if (!match) {
        return null;
      }
      const sign = match[1] === "-" ? -1 : 1;
      const hours = Number.parseInt(match[2], 10);
      const minutes = match[3] ? Number.parseInt(match[3], 10) : 0;
      if (Number.isNaN(hours) || Number.isNaN(minutes) || hours > 14 || minutes > 59) {
        return null;
      }
      return sign * (hours * 60 + minutes);
    }

    function formatTimeWithOffset(date, offsetMinutes, options) {
      const adjusted = new Date(date.getTime() + offsetMinutes * 60 * 1000);
      return adjusted.toLocaleTimeString("en-US", {
        ...options,
        timeZone: "UTC",
      });
    }

    function formatDateWithOffset(date, offsetMinutes, options) {
      const adjusted = new Date(date.getTime() + offsetMinutes * 60 * 1000);
      return adjusted.toLocaleDateString("en-US", {
        ...options,
        timeZone: "UTC",
      });
    }

    function getZonedParts(date, timeZone) {
      if (timeZone) {
        const offsetMinutes = parseTimeZoneOffset(timeZone);
        if (offsetMinutes !== null) {
          const adjusted = new Date(date.getTime() + offsetMinutes * 60 * 1000);
          return {
            year: adjusted.getUTCFullYear(),
            month: adjusted.getUTCMonth(),
            day: adjusted.getUTCDate(),
            hour: adjusted.getUTCHours(),
            minute: adjusted.getUTCMinutes(),
          };
        }
        try {
          const parts = new Intl.DateTimeFormat("en-US", {
            timeZone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          }).formatToParts(date);
          const lookup = Object.fromEntries(parts.map((part) => [part.type, part.value]));
          return {
            year: Number.parseInt(lookup.year, 10),
            month: Number.parseInt(lookup.month, 10) - 1,
            day: Number.parseInt(lookup.day, 10),
            hour: Number.parseInt(lookup.hour, 10),
            minute: Number.parseInt(lookup.minute, 10),
          };
        } catch (error) {
          // Fall through to local time
        }
      }
      return {
        year: date.getFullYear(),
        month: date.getMonth(),
        day: date.getDate(),
        hour: date.getHours(),
        minute: date.getMinutes(),
      };
    }

    function isSameDay(first, second, timeZone) {
      const firstParts = getZonedParts(first, timeZone);
      const secondParts = getZonedParts(second, timeZone);
      return (
        firstParts.year === secondParts.year &&
        firstParts.month === secondParts.month &&
        firstParts.day === secondParts.day
      );
    }

    function isWithinWorkHours(date, timeZone) {
      const WORKDAY_START = 9;
      const WORKDAY_END = 17;
      const parts = getZonedParts(date, timeZone);
      return parts.hour >= WORKDAY_START && parts.hour < WORKDAY_END;
    }

    function formatTime(date, timeZone) {
      const baseOptions = {
        hour: "numeric",
        minute: "2-digit",
        hour12: true,
      };
      if (timeZone) {
        const offsetMinutes = parseTimeZoneOffset(timeZone);
        if (offsetMinutes !== null) {
          return formatTimeWithOffset(date, offsetMinutes, baseOptions);
        }
        try {
          return date.toLocaleTimeString("en-US", {
            ...baseOptions,
            timeZone,
          });
        } catch (error) {
          return date.toLocaleTimeString("en-US", baseOptions);
        }
      }
      return date.toLocaleTimeString("en-US", baseOptions);
    }

    function formatDate(date, timeZone) {
      const baseOptions = {
        month: "2-digit",
        day: "2-digit",
        year: "numeric",
      };
      if (timeZone) {
        const offsetMinutes = parseTimeZoneOffset(timeZone);
        if (offsetMinutes !== null) {
          return formatDateWithOffset(date, offsetMinutes, baseOptions);
        }
        try {
          return date.toLocaleDateString("en-US", {
            ...baseOptions,
            timeZone,
          });
        } catch (error) {
          return date.toLocaleDateString("en-US", baseOptions);
        }
      }
      return date.toLocaleDateString("en-US", baseOptions);
    }

    function updateNextEvent(nextEventAt, state) {
      if (!nextEventAt || state === "ooo") {
        nextEvent.textContent = "";
        return;
      }
      const nextTime = new Date(nextEventAt);
      if (Number.isNaN(nextTime.getTime())) {
        nextEvent.textContent = "";
        return;
      }
      const now = new Date();
      if (nextTime <= now) {
        nextEvent.textContent = "";
        return;
      }
      if (!isSameDay(nextTime, now)) {
        nextEvent.textContent = "";
        return;
      }
      if (!isWithinWorkHours(nextTime)) {
        nextEvent.textContent = "";
        return;
      }
      const formattedTime = formatTime(nextTime);
      nextEvent.textContent = `Next event at ${formattedTime}`;
    }

    function updateClock() {
      const now = new Date();
      footer.textContent = `${formatDate(now, currentTimeZone)} ${formatTime(now, currentTimeZone)}`;
    }

    async function loadStatus() {
      try {
        const r = await fetch("/status.json?cache=" + Date.now());
        const data = await r.json();
        const state = data.state || "error";
        bar.className = "bar " + state;
        icon.textContent = iconByState[state] || "‚óè";
        label.textContent = data.label || "UNKNOWN";
        detail.textContent = data.detail || "";
        currentUntil = data.until || null;
        currentNextEventAt = data.next_event_at || null;
        currentTimeZone = data.time_zone || null;
        currentState = state;
        updateCountdown(currentUntil, currentState);
        updateNextEvent(currentNextEventAt, currentState);
      } catch (e) {
        bar.className = "bar error";
        icon.textContent = iconByState.error;
        label.textContent = "STATUS ERROR";
        detail.textContent = "";
        nextEvent.textContent = "";
        countdown.textContent = "";
        currentUntil = null;
        currentNextEventAt = null;
        currentState = "error";
      }
    }

    setInterval(updateClock, 1000);
    setInterval(loadStatus, 2000);
    setInterval(() => updateCountdown(currentUntil, currentState), 1000);
    setInterval(() => updateNextEvent(currentNextEventAt, currentState), 1000);
    updateClock();
    loadStatus();
  </script>
</body>
</html>
