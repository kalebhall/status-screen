<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0" />
  <title>Status Display</title>
  <style>
    :root {
      color-scheme: only dark;
    }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: black;
      color: white;
      overflow: hidden;
      cursor: none;
    }
    .screen {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: stretch;
    }
    .row {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: calc(10px * var(--font-scale, 1));
      text-align: center;
      padding: calc(16px * var(--font-scale, 1));
      box-sizing: border-box;
    }
    .row + .row {
      border-top: 4px solid rgba(255, 255, 255, 0.2);
    }
    .label-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: calc(24px * var(--font-scale, 1));
    }
    .name {
      font-size: calc(64px * var(--font-scale, 1));
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    .label {
      font-size: calc(140px * var(--font-scale, 1));
      line-height: 1.0;
      font-weight: 700;
      text-transform: uppercase;
    }
    .status-icon {
      font-size: calc(120px * var(--font-scale, 1));
      line-height: 1.0;
      filter: drop-shadow(0 4px 4px rgba(0,0,0,0.35));
    }
    .detail {
      font-size: calc(64px * var(--font-scale, 1));
      opacity: 0.9;
      text-transform: none;
    }
    .next-event,
    .countdown {
      font-size: calc(52px * var(--font-scale, 1));
      opacity: 0.85;
      text-transform: none;
    }
    .available { background: #00a651; }
    .busy { background: #c0392b; }
    .meeting { background: #2980b9; }
    .ooo { background: #8e44ad; }
    .error { background: #7f8c8d; }
    .footer {
      position: absolute;
      bottom: 20px;
      right: 40px;
      font-size: calc(42px * var(--font-scale, 1));
      opacity: 0.85;
    }
  </style>
</head>
<body>
  <div id="screen" class="screen"></div>
  <div id="footer" class="footer"></div>

  <script>
    const footer = document.getElementById("footer");
    const screen = document.getElementById("screen");
    let rows = [];
    let rowState = [];

    const iconByState = {
      available: "‚úÖ",
      busy: "‚õî",
      meeting: "üìÖ",
      ooo: "‚úàÔ∏è",
      error: "‚ö†Ô∏è",
    };

    function fontScaleFor(count) {
      if (count <= 1) {
        return 1;
      }
      if (count === 2) {
        return 0.75;
      }
      if (count === 3) {
        return 0.6;
      }
      if (count === 4) {
        return 0.5;
      }
      return 0.4;
    }

    function createRow() {
      const row = document.createElement("div");
      row.className = "row available";

      const name = document.createElement("div");
      name.className = "name";

      const labelRow = document.createElement("div");
      labelRow.className = "label-row";

      const icon = document.createElement("span");
      icon.className = "status-icon";
      icon.textContent = "‚óè";

      const label = document.createElement("span");
      label.className = "label";
      label.textContent = "AVAILABLE";

      labelRow.appendChild(icon);
      labelRow.appendChild(label);

      const detail = document.createElement("div");
      detail.className = "detail";

      const nextEvent = document.createElement("div");
      nextEvent.className = "next-event";

      const countdown = document.createElement("div");
      countdown.className = "countdown";

      row.appendChild(name);
      row.appendChild(labelRow);
      row.appendChild(detail);
      row.appendChild(nextEvent);
      row.appendChild(countdown);

      return { row, name, icon, label, detail, nextEvent, countdown };
    }

    function setRowCount(count) {
      const targetCount = Math.max(1, count);
      if (rows.length === targetCount) {
        return;
      }
      screen.innerHTML = "";
      rows = [];
      rowState = [];
      for (let i = 0; i < targetCount; i += 1) {
        const row = createRow();
        rows.push(row);
        rowState.push({
          until: null,
          state: "available",
          nextEventAt: null,
          detail: "",
          source: "",
          timeZone: null,
        });
        screen.appendChild(row.row);
      }
      screen.style.setProperty("--font-scale", fontScaleFor(targetCount));
    }

    function formatCountdown(msRemaining) {
      const totalSeconds = Math.max(0, Math.floor(msRemaining / 1000));
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      if (minutes > 0) {
        return `${minutes}m ${seconds}s`;
      }
      return `${seconds}s`;
    }

    function isMicActive(detail) {
      return (detail || "").toLowerCase().includes("mic active");
    }

    function updateCountdown(index) {
      const state = rowState[index];
      const row = rows[index];
      if (
        !row ||
        !state ||
        !state.until ||
        ["available", "ooo"].includes(state.state) ||
        isMicActive(state.detail)
      ) {
        if (row) {
          row.countdown.textContent = "";
        }
        return;
      }
      const endTime = new Date(state.until);
      if (Number.isNaN(endTime.getTime())) {
        row.countdown.textContent = "";
        return;
      }
      const remaining = endTime.getTime() - Date.now();
      if (remaining <= 0) {
        row.countdown.textContent = "Ending now";
        return;
      }
      row.countdown.textContent = `Ends in ${formatCountdown(remaining)}`;
    }

    function formatTime(date) {
      const baseOptions = {
        hour: "numeric",
        minute: "2-digit",
        hour12: true,
      };
      return date.toLocaleTimeString("en-US", baseOptions);
    }

    function formatDate(date) {
      const baseOptions = {
        month: "2-digit",
        day: "2-digit",
        year: "numeric",
      };
      return date.toLocaleDateString("en-US", baseOptions);
    }

    function updateNextEvent(index) {
      const state = rowState[index];
      const row = rows[index];
      if (!row || !state || !state.nextEventAt || state.state === "ooo") {
        if (row) {
          row.nextEvent.textContent = "";
        }
        return;
      }
      const nextTime = new Date(state.nextEventAt);
      if (Number.isNaN(nextTime.getTime())) {
        row.nextEvent.textContent = "";
        return;
      }
      const now = new Date();
      if (nextTime <= now) {
        row.nextEvent.textContent = "";
        return;
      }
      const formattedTime = formatTime(nextTime);
      row.nextEvent.textContent = `Next event at ${formattedTime}`;
    }

    function updateClock() {
      const now = new Date();
      footer.textContent = `${formatDate(now)} ${formatTime(now)}`;
    }

    function updateRow(index, person) {
      const row = rows[index];
      if (!row) {
        return;
      }
      const state = person.state || "error";
      row.row.className = `row ${state}`;
      row.icon.textContent = iconByState[state] || "‚óè";
      row.label.textContent = person.label || "UNKNOWN";
      row.detail.textContent = person.detail || "";
      row.name.textContent = person.name || `Group ${index + 1}`;
      rowState[index] = {
        until: person.until || null,
        state,
        nextEventAt: person.next_event_at || null,
        detail: person.detail || "",
        source: person.source || "",
      };
      updateCountdown(index);
      updateNextEvent(index);
    }

    async function fetchStatusPayload() {
      try {
        const r = await fetch("/status-multi.json?cache=" + Date.now());
        if (!r.ok) {
          throw new Error(`status-multi.json ${r.status}`);
        }
        return await r.json();
      } catch (error) {
        try {
          const r = await fetch("/status.json?cache=" + Date.now());
          if (!r.ok) {
            throw new Error(`status.json ${r.status}`);
          }
          return await r.json();
        } catch (fallbackError) {
          return null;
        }
      }
    }

    async function loadStatus() {
      const data = await fetchStatusPayload();
      if (!data) {
        setRowCount(1);
        updateRow(0, { state: "error", label: "STATUS ERROR", detail: "" });
        return;
      }
      const people = Array.isArray(data.people) ? data.people : [data];
      setRowCount(people.length);
      people.forEach((person, index) => updateRow(index, person));
    }

    setInterval(updateClock, 1000);
    setInterval(loadStatus, 2000);
    setInterval(() => rows.forEach((_, index) => updateCountdown(index)), 1000);
    setInterval(() => rows.forEach((_, index) => updateNextEvent(index)), 1000);
    updateClock();
    loadStatus();
  </script>
</body>
</html>
